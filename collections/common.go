package collections

// ToDictionary converts a list of items to a map of items based on the output of
// a function that gets a key from each item and a Boolean value that determines
// whether conflicts should be overwritten
func ToDictionary[T any, U comparable](mapping map[U]T, list []T, keyer func(int, T) U, overwrite bool) {
	for i, item := range list {

		// Use the keyer to get a key from the item
		key := keyer(i, item)

		// If the mapping already contains the item then we'll either
		// ignore it, or if overwrite is true, we'll save the item to
		// the map; otherwise, save the item anyway
		if _, ok := mapping[key]; !ok || overwrite {
			mapping[key] = item
		}
	}
}

// ToDictionaryKeys works similarly to the ToDictionary function except that, the list
// provided will be used as the keys and the valuer function will be used to generate a
// value for the map associated with the key. This can be useful when trying to index on
// a struct property
func ToDictionaryKeys[T comparable, U any](mapping map[T]U, list []T, valuer func(int, T) U, overwrite bool) {
	for i, item := range list {

		// Use the keyer to get a key from the item
		value := valuer(i, item)

		// If the mapping already contains the item then we'll either
		// ignore it, or if overwrite is true, we'll save the item to
		// the map; otherwise, save the item anyway
		if _, ok := mapping[item]; !ok || overwrite {
			mapping[item] = value
		}
	}
}

// Index creates an index between the values in a list and their indices
func Index[T comparable](list []T) map[T]int {
	mapping := make(map[T]int)
	ToDictionaryKeys(mapping, list, func(index int, value T) int {
		return index
	}, false)

	return mapping
}

// IndexWithFunction creates an index on a slice of data, where the key is
// generated by the converter function provided, and the value is the index
// of the value that produced the key in the slice
func IndexWithFunction[T any, U comparable](list []T, converter func(T) U) map[U]int {
	mapping := make(map[U]int)
	for i, item := range list {
		key := converter(item)
		mapping[key] = i
	}

	return mapping
}

// AsSlice converts a parameterized list of items to a slice
func AsSlice[T any](data ...T) []T {
	return data
}

// Convert converts all the items in a list from a first type to
// a second type, using the function provided
func Convert[T any, U any](converter func(T) U, data ...T) []U {
	converted := make([]U, len(data))
	for i, item := range data {
		converted[i] = converter(item)
	}

	return converted
}
